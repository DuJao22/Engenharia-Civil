Sistema Completo de CÃ¡lculos de Engenharia Civil â€” JoÃ£o Layon

Documento de projeto, fÃ³rmulas, esquema de banco de dados e esboÃ§o de implementaÃ§Ã£o (Flask + Python + SQLite + Mercado Pago). Este documento foi gerado para servir como base completa para um sistema SaaS de cÃ¡lculos de Engenharia Civil com gestÃ£o de perfis/pagamentos.

1. Objetivo

Construir um sistema web (SaaS) para engenheiros civis que reÃºna todas (ou a maioria das) calculadoras e rotinas usadas no dia a dia: estruturas, fundaÃ§Ãµes, lajes, vigas, pilares, hidrÃ¡ulica, saneamento, geotecnia, orÃ§amentos, topografia, pavimentaÃ§Ã£o, dimensionamento de redes, cronogramas, controle de materiais e composiÃ§Ãµes de custo.

CrÃ©ditos e marca: JoÃ£o Layon â€” todo o sistema deverÃ¡ ostentar sua marca e crÃ©ditos.

Tecnologias sugeridas: Python 3.11+, Flask, Jinja2, SQLite (ou PostgreSQL), TailwindCSS para frontend, Mercado Pago para pagamentos (PIX/cartÃ£o).

2. Funcionalidades principais
2.1 AutenticaÃ§Ã£o e planos

Cadastro/login (email + senha). Hashing de senha com bcrypt.

Perfis/Planos: Gratuito (demo), Pro (mensal/Anual) â€” acesso aos mÃ³dulos conforme plano.

IntegraÃ§Ã£o Mercado Pago: gerar pagamentos PIX e cartÃ£o; webhook para confirmaÃ§Ã£o e liberaÃ§Ã£o automÃ¡tica.

2.2 MÃ³dulos de cÃ¡lculo

Estruturas: determinaÃ§Ã£o de esforÃ§os (N, V, M), dimensionamento concreto armado (vigas, pilares, lajes), verificaÃ§Ã£o de armaduras, flechas.

Concreto armado: dimensionamento por estados limite Ãºltimo (ELU) e de serviÃ§o (ELS).

AÃ§o: dimensionamento de perfis e ligaÃ§Ãµes; verificaÃ§Ã£o por flambagem.

FundaÃ§Ãµes: sapatas isoladas, sapatas corridas, blocos, radier, estacas (capacidade Ãºltima, recalques estimados).

Geotecnia: propriedades do solo, empuxos, capacidade de carga por Terzaghi e Meyerhof, adensamento simples.

HidrÃ¡ulica & Saneamento: Bernoulli, perda de carga (Darcy-Weisbach e Hazen-Williams), cÃ¡lculos de drenagem pluvial (mÃ©todo racional), dimensionamento de tubulaÃ§Ãµes.

OrÃ§amentos (ComposiÃ§Ãµes): consumo de concreto, ferros, traÃ§os de argamassa, quantitativos, SINAPI/TCPO compatÃ­vel.

Topografia: Ã¡reas por coordenadas (shoelace), volume por seÃ§Ãµes transversais, nivelamento.

PavimentaÃ§Ã£o: dimensionamento de pavimentos flexÃ­veis e rÃ­gidos, equivalÃªncia de eixos (ESAL).

Cronograma: CPM/PERT bÃ¡sico, cÃ¡lculo de folgas e caminho crÃ­tico.

2.3 HistÃ³rico e relatÃ³rios

Salvar cada cÃ¡lculo com inputs e resultados.

ExportaÃ§Ã£o PDF/Word/CSV dos relatÃ³rios e orÃ§amentos.

2.4 Admin (JoÃ£o Layon)

Gerenciar planos, usuÃ¡rios, redefinir senhas, ver relatÃ³rios de receita, emitir notas (integraÃ§Ã£o futura).

3. Esquema de banco de dados (SQLite â€” tabelas principais)
-- users
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  email TEXT UNIQUE,
  password_hash TEXT,
  plan TEXT,
  plan_expires DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);


-- payments
CREATE TABLE payments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  mp_payment_id TEXT,
  amount REAL,
  currency TEXT,
  method TEXT,
  status TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);


-- calculations (generic storage)
CREATE TABLE calculations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  module TEXT,
  name TEXT,
  inputs TEXT, -- JSON
  results TEXT, -- JSON
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
);
4. Fluxo de pagamento com Mercado Pago (resumo tÃ©cnico)

No frontend, usuÃ¡rio escolhe plano e clica em pagar.

Backend (Flask) cria uma preferÃªncia / pagamento via SDK Mercado Pago (ou cria um order e gera QRCode PIX). Retorna link/checkout/pix_qr.

UsuÃ¡rio conclui o pagamento.

Mercado Pago envia webhook com payment.status = approved.

Endpoint webhook atualiza payments e ativa users.plan_expires.

Login valida plan_expires antes de liberar mÃ³dulos pagos.

SeguranÃ§a: validar assinatura do webhook e restringir IPs se possÃ­vel.

5. FÃ³rmulas e algoritmos por mÃ³dulo (resumo prÃ¡tico e implementÃ¡vel)

Abaixo estÃ£o as fÃ³rmulas mais usadas por cada disciplina e um breve algoritmo de como aplicÃ¡-las.

5.1 Estruturas â€” EsforÃ§os internos

TensÃ£o normal: $\sigma = \dfrac{N}{A}$

TensÃ£o de cisalhamento mÃ©dia: $\tau = \dfrac{V}{A}$

Momento fletor para carregamento pontual P no centro de viga simplesmente apoiada: $M_{max} = \dfrac{P \cdot L}{4}$

Momento fletor para carregamento uniformemente distribuÃ­do w: $M_{max} = \dfrac{w L^{2}}{8}$

Algoritmo: receber carregamentos (pontual, distribuÃ­do), apoio (simples, engastado), calcular diagramas de esforÃ§o cortante e momento (usando mÃ©todo das seÃ§Ãµes com integraÃ§Ã£o ou formula direta para casos padrÃ£o).

5.2 Concreto armado â€” dimensionamento de viga retangular (simplificado, mÃ©todo brasileiro)

Momento resistente (M def): usar la norma (NBR 6118) para obter as fck, fyk, coeficientes.

Ãrea de aÃ§o mÃ­nima (As,min): regra prÃ¡tica: $A_{s,min} \approx 0,0015 \cdot b \cdot d$ (varia por norma).

EquilÃ­brio para cÃ¡lculo de As: $M_{sd} = A_{s} \cdot f_{yd} \cdot z$ onde $z \approx 0.9 d$ (aprox.).

Passos:

Calcular $M_{sd}$ (momento de projeto, combinaÃ§Ãµes de cargas).

Assumir alavanca z (0.85â€“0.95 d) e resolver $A_s = \dfrac{M_{sd}}{f_{yd} \cdot z}$.

Verificar cobrimento e bitola/ espaÃ§amento segundo norma.

Nota: Para precisÃ£o total, implementar rotina que calcule posiÃ§Ã£o da linha neutra usando curva concreta e diagrama de tensÃµes (parÃ¢metro k).

5.3 Pilares (concreto) â€” verificaÃ§Ã£o axial + momento (interaction)

CÃ¡lculo pelo mÃ©todo das curvas interaÃ§Ã£o (N-M). Utilizar capacidade de compressÃ£o da seÃ§Ã£o e reduzir por excentricidade.

Formula bÃ¡sica tensÃ£o mÃ©dia: $\sigma_m = \dfrac{N_{sd}}{A_c}$; verificar com capacidade Ãºltima $N_Rd$.

5.4 Flecha (deflexÃ£o) â€” viga simplesmente apoiada com carga concentrada

Flecha mÃ¡xima para carga concentrada P no centro: $\delta_{max} = \dfrac{P L^{3}}{48 E I}$

Para carga uniformemente distribuÃ­da: $\delta_{max} = \dfrac{5 w L^{4}}{384 E I}$

Onde: $I$ momento de inÃ©rcia da seÃ§Ã£o, $E$ mÃ³dulo de elasticidade.

5.5 Perdas de carga em tubulaÃ§Ãµes

Darcy-Weisbach: $h_f = f \dfrac{L}{D} \dfrac{V^{2}}{2g}$

NÃºmero de Reynolds: $Re = \dfrac{V D}{\nu}$

CÃ¡lculo do fator f: Colebrook-White (iterativo) ou fÃ³rmula de Swamee-Jain (explÃ­cita):

ğ‘“
=
0.25
[
log
â¡
10
(
ğœ€
/
ğ·
3.7
+
5.74
ğ‘…
ğ‘’
0.9
)
]
âˆ’
2
f=0.25[log
10
	â€‹

(
3.7
Îµ/D
	â€‹

+
Re
0.9
5.74
	â€‹

)]
âˆ’2



Hazen-Williams (Ã¡gua potÃ¡vel, menos preciso):

â„
ğ‘“
=
10.67
â‹…
ğ¿
â‹…
ğ‘„
1.852
ğ¶
1.852
ğ·
4.87
h
f
	â€‹

=10.67â‹…Lâ‹…
C
1.852
D
4.87
Q
1.852
	â€‹




5.6 MÃ©todo racional para dimensionar Ã¡guas pluviais

$Q = C \cdot i \cdot A$

$Q$ = vazÃ£o (mÂ³/s), $C$ = coeficiente de escoamento (adimensional), $i$ = intensidade da chuva (m/s), $A$ = Ã¡rea (mÂ²).

Intensidade i pode ser obtida via curva de intensidade-duraÃ§Ã£o-frequÃªncia (IDF) local.

5.7 Capacidade de carga de fundaÃ§Ãµes rasas (Terzaghi)

Capacidade Ãºltima aproximada (sapata strip):

ğ‘
ğ‘¢
ğ‘™
ğ‘¡
=
ğ‘
ğ‘
ğ‘
+
ğ›¾
ğ·
ğ‘“
ğ‘
ğ‘
+
0.5
ğ›¾
ğµ
ğ‘
ğ›¾
q
ult
	â€‹

=cN
c
	â€‹

+Î³D
f
	â€‹

N
q
	â€‹

+0.5Î³BN
Î³
	â€‹




onde $N_c, N_q, N_\gamma$ sÃ£o fatores dependentes do Ã¢ngulo de atrito $\phi$.

Fator de seguranÃ§a: $q_{adm} = \dfrac{q_{ult}}{FS}$

5.8 Empuxo de terra (Rankine â€” inclinaÃ§Ã£o vertical)

Empuxo ativo: $E_a = \frac{1}{2} \gamma H^{2} K_a$ onde $K_a = \tan^{2}\left(45-\dfrac{\phi}{2}\right)$

Empuxo passivo: $K_p = \tan^{2}\left(45+\dfrac{\phi}{2}\right)$

5.9 Topografia â€” Ã¡rea por coordenadas (shoelace)

Para polÃ­gono com vÃ©rtices $(x_i,y_i)$:

ğ´
=
1
2
âˆ£
âˆ‘
ğ‘–
=
1
ğ‘›
âˆ’
1
(
ğ‘¥
ğ‘–
ğ‘¦
ğ‘–
+
1
âˆ’
ğ‘¥
ğ‘–
+
1
ğ‘¦
ğ‘–
)
+
(
ğ‘¥
ğ‘›
ğ‘¦
1
âˆ’
ğ‘¥
1
ğ‘¦
ğ‘›
)
âˆ£
A=
2
1
	â€‹

	â€‹

âˆ‘
i=1
nâˆ’1
	â€‹

(x
i
	â€‹

y
i+1
	â€‹

âˆ’x
i+1
	â€‹

y
i
	â€‹

)+(x
n
	â€‹

y
1
	â€‹

âˆ’x
1
	â€‹

y
n
	â€‹

)
	â€‹




5.10 Volume por seÃ§Ãµes (prismoidal/simple trapezoidal)

Volume entre duas seÃ§Ãµes $A_1$ e $A_2$ separadas por distÃ¢ncia $L$:

ğ‘‰
=
ğ¿
2
(
ğ´
1
+
ğ´
2
)
V=
2
L
	â€‹

(A
1
	â€‹

+A
2
	â€‹

)


Para mÃ©todo prismoidal (melhor precisÃ£o):

ğ‘‰
=
ğ¿
6
(
ğ´
1
+
4
ğ´
ğ‘š
+
ğ´
2
)
V=
6
L
	â€‹

(A
1
	â€‹

+4A
m
	â€‹

+A
2
	â€‹

)


onde $A_m$ Ã© Ã¡rea na seÃ§Ã£o mÃ©dia.

5.11 OrÃ§amento â€” consumo de concreto e aÃ§o

Volume de concreto: $V_c = \text{comprimento} \times \text{largura} \times \text{altura}$

Consumo de aÃ§o (estimativa): para lajes maciÃ§as $\approx$ 80â€“120 kg/mÂ³ (varia conforme projeto). Para vigas/pilares calcular As e converter para kg usando comprimento e diÃ¢metros das barras.

6. Interface de usuÃ¡rio (visÃ£o geral)

Dashboard inicial com mÃ³dulos e status do plano.

NavegaÃ§Ã£o lateral: Estruturas, FundaÃ§Ãµes, HidrÃ¡ulica, Topografia, OrÃ§amentos, HistÃ³rico, Conta.

Tela de cÃ¡lculo: formulÃ¡rio (inputs), botÃ£o calcular, visualizaÃ§Ã£o grÃ¡fica (diagramas de momento/cortante), botÃ£o salvar/exportar.

Ãrea admin com grÃ¡ficos de receita, lista de usuÃ¡rios e pagamentos.

7. EsboÃ§o de endpoints Flask (exemplos)
# app.py (trecho)
from flask import Flask, request, jsonify, render_template
from models import db, User, Payment, Calculation


app = Flask(__name__)


@app.route('/api/calculate/beam', methods=['POST'])
def calc_beam():
    data = request.json
    # exemplo: calcular momento max para carga uniforme
    L = data['L']
    w = data['w']
    Mmax = w * L**2 / 8
    result = {'Mmax': Mmax}
    # salvar em calculations
    return jsonify(result)


@app.route('/webhook/mercadopago', methods=['POST'])
def mp_webhook():
    payload = request.json
    # validar assinatura
    # atualizar payments e ativar user
    return '', 200
8. Boas prÃ¡ticas e seguranÃ§a

Hash de senhas com bcrypt + salt.

HTTPS obrigatÃ³rio (Let's Encrypt em produÃ§Ã£o).

ValidaÃ§Ã£o rigorosa dos inputs de cÃ¡lculo (limites, unidades).

Testes unitÃ¡rios e de integraÃ§Ã£o (pytest).

Logs e monitoramento de erros (Sentry ou similar).

9. Roadmap e entregÃ¡veis (versÃµes)

MVP (2â€“4 semanas): AutenticaÃ§Ã£o, 5 calculadoras essenciais (viga, pilar, sapata, volume, orÃ§amento), histÃ³rico, integraÃ§Ã£o Mercado Pago bÃ¡sica.

v1.1: Mais calculadoras (flecha, interaÃ§Ã£o N-M), relatÃ³rios em PDF, export CSV.

v2.0: MÃ³dulos avanÃ§ados (adensamento, pavimentaÃ§Ã£o), multi-idioma, integraÃ§Ã£o com banco comercial.

10. Anexos â€” trechos de fÃ³rmulas e snippets Ãºteis (Python)

Colebrook-White (iterativa)

import math


def colebrook(f_guess, Re, eps, D):
    # f_guess: chute inicial
    f = f_guess
    for _ in range(50):
        lhs = 1/math.sqrt(f)
        rhs = -2*math.log10( (eps/(3.7*D)) + (2.51/(Re*math.sqrt(f))) )
        f_new = 1/(rhs**2)
        if abs(f_new-f) < 1e-6:
            return f_new
        f = f_new
    return f

Shoelace (Ã¡rea poligonal)

def shoelace(coor